extern crate proc_macro;

use proc_macro::TokenStream;
use quote::{format_ident, quote, ToTokens};
use syn::parse::{Parse, ParseStream, Parser};
use syn::punctuated::Punctuated;
use syn::token::Comma;
use syn::{parse, parse_macro_input, FnArg, ImplItemFn, ReturnType, TraitItemFn, Type, TypePath};

struct DeclAttrs {
    generic: TypePath,
}

impl Parse for DeclAttrs {
    fn parse(input: ParseStream) -> parse::Result<Self> {
        Ok(DeclAttrs {
            generic: input.parse()?,
        })
    }
}

type ImplAttrs = Punctuated<TypePath, Comma>;

#[proc_macro_attribute]
pub fn implbox_decls(args: TokenStream, input: TokenStream) -> TokenStream {
    let item_decl = parse_macro_input!(input as TraitItemFn);
    let attr = parse_macro_input!(args as DeclAttrs);
    let generic_type = attr.generic;
    let orig = item_decl.clone();

    let sig = item_decl.sig;
    let generics = sig.generics;
    let ident = sig.ident;
    let asyncness = sig.asyncness;
    let constness = sig.constness;
    let inputs = sig.inputs;
    let output = sig.output;
    let unsafety = sig.unsafety;
    let output = create_box_output(output);

    let ident_str = ident.to_string();
    let Some(base) = ident_str.strip_prefix("new_") else {
        panic!("function for implbox_decls must be new_something");
    };

    let box_fn = format_ident!("box_{}", base);
    let unbox_fn = format_ident!("unbox_{}", base);
    let drop_fn = format_ident!("drop_{}", base);

    // `pub`, `default`, `const`, `async`, `unsafe`, `extern`
    let gen = quote! {
        #orig
        /// Generated by implbox_decls -- call to create the boxed value
        #asyncness #constness #unsafety fn #box_fn #generics (#inputs) -> ImplBox<#generic_type>;
        /// Generated by implbox_decls -- call to retrieve original value
        fn #unbox_fn #generics(l: &ImplBox<#generic_type>) #output;
        /// Generated by implbox_decls -- called automatically
        fn #drop_fn #generics (p: *const ());
    };
    gen.into()
}

#[proc_macro_attribute]
pub fn implbox_impls(args: TokenStream, input: TokenStream) -> TokenStream {
    let item_impl = parse_macro_input!(input as ImplItemFn);
    let attr = ImplAttrs::parse_terminated.parse(args).unwrap();
    let mut iter = attr.iter();
    let generic_type = iter.next().unwrap();
    let concrete_path = iter.next().unwrap();
    if iter.next().is_some() {
        panic!("too many parameters to implbox_impls");
    }
    let orig = item_impl.clone();

    let sig = item_impl.sig;
    let generics = sig.generics;
    let ident = sig.ident;
    let asyncness = sig.asyncness;
    let constness = sig.constness;
    let inputs = sig.inputs;
    let output = sig.output;
    let unsafety = sig.unsafety;
    let output = create_box_output(output);
    let (_g_impl, g_type, _g_where) = generics.split_for_impl();
    let g_fish = g_type.as_turbofish();

    let ident_str = ident.to_string();
    let Some(base) = ident_str.strip_prefix("new_") else {
        panic!("function for implbox_decls must be new_something");
    };

    let box_fn = format_ident!("box_{}", base);
    let unbox_fn = format_ident!("unbox_{}", base);
    let drop_fn = format_ident!("drop_{}", base);

    let mut params = Vec::new();
    for arg in inputs.iter() {
        match arg {
            FnArg::Receiver(r) => params.push(r.to_token_stream()),
            FnArg::Typed(t) => params.push(t.pat.to_token_stream()),
        }

        params.push(quote! {});
    }

    // `pub`, `default`, `const`, `async`, `unsafe`, `extern`
    let gen = quote! {
        #orig
        #asyncness #constness #unsafety fn #box_fn #generics (#inputs) -> ImplBox<#generic_type> {
            let item = Self::#ident(#(#params)*);
            let ptr = Box::into_raw(Box::new(item));
            ImplBox::new(std::any::TypeId::of::<Self>(), Self::#drop_fn #g_fish, ptr as *const ())
        }

        fn #unbox_fn #generics (l: &ImplBox<#generic_type>) #output {
            l.with(std::any::TypeId::of::<Self>(), |p| {
                let p = p as *const #concrete_path;
                unsafe { p.as_ref() }.unwrap()
            })
        }

        fn #drop_fn #generics (p: *const ()) {
            drop(unsafe { Box::from_raw(p as *mut #concrete_path) });
        }
    };
    gen.into()
}

fn create_box_output(orig: ReturnType) -> ReturnType {
    match orig {
        ReturnType::Default => ReturnType::Default,
        ReturnType::Type(arr, t) => {
            let t = *t;
            let tokens = t.to_token_stream();
            let tokens_str = tokens.to_string();
            if !tokens_str.starts_with("impl ") {
                panic!("original return type must start with impl");
            }
            let t = quote! { &#tokens };
            let t: Type = syn::parse2(t).unwrap();
            ReturnType::Type(arr, Box::new(t))
        }
    }
}
